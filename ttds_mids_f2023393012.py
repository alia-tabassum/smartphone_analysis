# -*- coding: utf-8 -*-
"""TTDS Mids 2023393012.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CpVWfdguFF9mXqgBqWFr34enjuEqOmwm
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import re

df = pd.read_csv('/content/smartphone_Given.csv')

df.head()

# Removing "Rs" From Price
df['price'] = df['Price'].str.replace('Rs.', '')

# spliting sim column
# Check for the presence of "5G", "NFC" and "IR Blaset" in the "sim_data" column
df['has_5g'] = df['sim'].str.contains('5G', case=False, na=False)
df['has_nfc'] = df['sim'].str.contains('NFC', case=False, na=False)
df['has_ir_blaster'] = df['sim'].str.contains('IR Blaster', case=False, na=False)
df['brand_name'] = df['model'].str.split().str[0]

df['processor_brand'] = df['processor'].str.split().str[0]
df.loc[df['processor'].str.split().str[0].str.contains('Octa|Core', case=False, na=False), 'processor_brand'] = ''
df['num_cores'] = df['processor'].str.extract(r'(\w+ Core)', expand=False)
processor_speeds = df['processor'].str.extract(r'(\d+\.?\d*)\??\s*GHz', expand=False)
df['processor_speed'] = processor_speeds.where(processor_speeds.str.match(r'^\d+\.?\d*$'), '')

df.head()

# Define a function to filter and extract battery capacity
def extract_battery_capacity(text):
    if 'mAh Battery' in text:
        # regex
        match = re.search(r'(\d+)\?mAh Battery', text)
        if match:
            return match.group(1)
    return ''


df['battery_capacity'] = df['battery'].apply(extract_battery_capacity)

columns = ['Price', 'sim', 'processor']
df.drop(columns, inplace=True, axis=1)

df.to_csv('/content/smartphone_Modified.csv', index=False)

# Define a function to extract fast charging values
def extract_fast_charging(text):
    # Use a regex to extract the numeric fast charging value
    match = re.search(r'(\d+)W Fast Charging', text)
    if match:
        return int(match.group(1))
    return 0

# Apply the function to the 'battery' column
df['fast_charging'] = df['battery'].apply(extract_fast_charging)

# Define a function to extract RAM capacity values
def extract_ram_capacity(text):
    # Use a regex to extract the numeric RAM capacity value
    match = re.search(r'(\d+)\?GB RAM', text)
    if match:
        return int(match.group(1))
    return 0

# Apply the function to the 'ram' column
df['ram_capacity'] = df['ram'].apply(extract_ram_capacity)


# Define a function to extract ROM capacity values
def extract_internal_memory(text):
    # Use a regex to extract the numeric RAM capacity value
    match = re.search(r'(\d+)\?GB inbuilt', text)
    if match:
        return int(match.group(1))
    return 0

# Apply the function to the 'ram' column
df['internal_memory'] = df['ram'].apply(extract_internal_memory)

columns = ['ram', 'battery']
df.drop(columns, inplace=True, axis=1)

# Define a function to extract Screen Size values
def extract_screen_size(text):
    # Use a regex to extract the numeric screen_size value
    match = re.search(r'(\d+\.?\d*)\s*inches', text)
    if match:
        return float(match.group(1))
    return 0.0

# Apply the function to the 'display' column
df['screen_size'] = df['display'].apply(extract_screen_size)

# Apply the function to the 'display' column
df['screen_size'] = df['display'].apply(extract_screen_size)

# Define a function to extract refresh rate values
def extract_refresh_rate(text):
    # Use a regex to extract the numeric refresh rate value
    match = re.search(r'(\d+)\s*Hz', text)
    if match:
        return int(match.group(1))
    return 0

# Apply the function to the 'display' column
df['refresh_rate'] = df['display'].apply(extract_refresh_rate)

# Define a function to extract and clean resolution from the 'display' column
def extract_resolution(display_text):
    import re
    pattern = r'(\d{3,4}\?x\?\d{3,4})'  # Updated regular expression pattern
    match = re.search(pattern, str(display_text))
    if match:
        resolution = match.group(1)
        return resolution.replace('?', '')  # Removing '?' characters
    else:
        return None

# Apply the function to create a new 'resolution' column
df['resolution'] = df['display'].apply(extract_resolution)

# D

columns = ['display']
df.drop(columns, inplace=True, axis=1)

# Remove '?' characters from the 'camera' column values
df['camera'] = df['camera'].str.replace('?', '')

# Define a function to count the occurrences of 'MP' before 'Rear' in each 'camera' text
def count_mp_before_rear(camera_text):
    if pd.isna(camera_text):  # Check if the value is NaN
        return 0
    else:
        rear_index = camera_text.find('Rear')  # Find the index of 'Rear' in the camera text
        if rear_index != -1:  # If 'Rear' is found
            mp_count = camera_text[:rear_index].count('MP')  # Count 'MP' occurrences before 'Rear'
            return mp_count
        else:
            return 0  # If 'Rear' is not found, return 0

# Create a new column 'num_rear_cameras' to store the count
df['num_rear_cameras'] = df['camera'].apply(count_mp_before_rear)

# Define a function to extract the MPs occurring after "Rear &" and return their count
def count_front_camera_mp(camera_text):
    if pd.isna(camera_text):  # Check if the value is NaN
        return 0
    else:
        rear_and_index = camera_text.find('Rear &')  # Find the index of 'Rear &' in the camera text
        if rear_and_index != -1:  # If 'Rear &' is found
            front_camera_text = camera_text[rear_and_index:]  # Extract text after "Rear &"
            mp_count = front_camera_text.count('MP')  # Count 'MP' occurrences after "Rear &"
            return mp_count
        else:
            return 0  # If "Rear &" is not found, return 0

# Create a new column 'front_camera_mp_count' to store the count of front camera MPs
df['num_front_cameras'] = df['camera'].apply(count_front_camera_mp)

df['primary_camera_rear'] = df['camera'].str.split().str[0].str.replace('MP', '')
df['primary_camera_front'] = df['camera'].str.extract(r'(\d+)\s*MP\s*Front')

# Extract OS value without alphanumeric characters and generate a new column 'os'
df['OS'] = df['os'].str.extract(r'([^\W\d_]+)')

# Fill NaN values in 'card' column with empty string
df['card'].fillna('', inplace=True)

# Assign 1 to 'extended_memory' where 'card' column contains 'Memory Card Supported'
df.loc[df['card'].str.contains('Memory Card Supported'), 'extended_memory'] = 1

# Assign 0 to 'extended_memory' where 'card' column contains 'Memory Card Not Supported'
df.loc[df['card'].str.contains('Memory Card Not Supported'), 'extended_memory'] = 0

# Assign 1 to 'extended_memory' where 'card' column contains 'Memory Card (Hybrid)'
df.loc[df['card'].str.contains('Memory Card \(Hybrid\)'), 'extended_memory'] = 1

# Fill NaN values in 'extended_memory' column with 0
df['extended_memory'].fillna(0, inplace=True)

# Cast 'extended_memory' column to integer
df['extended_memory'] = df['extended_memory'].astype(int)

# Fill NaN values in 'extended_memory' column with 0
df['extended_memory'].fillna(0, inplace=True)

# Cast 'extended_memory' column to integer
df['extended_memory'] = df['extended_memory'].astype(int)

columns = ['camera','card','os']
df.drop(columns, inplace=True, axis=1)

df.to_csv('/content/final_data.csv', index=False)

new_data = pd.read_csv('/content/final_data.csv')

new_data.head()

new_data.shape

new_data.dtypes

new_data.describe().T

# Select only numeric columns
numeric_columns = new_data.select_dtypes(include='number')

# Replace missing or null values with the mean of numeric columns
new_data[numeric_columns.columns] = numeric_columns.fillna(numeric_columns.mean())

print(new_data.isnull().sum())
print("----------------------------------------")

new_data.info()

plt.figure(figsize = (10, 6))
sns.barplot(x = 'price', y = 'rating', data = new_data, palette = 'Set3')
plt.xlabel('Price Range')
plt.ylabel('Ratng')
plt.show()

# 1. Data Overview
print(new_data.head())
print(new_data.info())
print(new_data.describe())

# 2. Distribution of Ratings
plt.figure(figsize=(8, 6))
sns.histplot(new_data['rating'], kde=True)
plt.title('Distribution of Phone Ratings')
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.show()

# 3. Relationship between Price and Rating
plt.figure(figsize=(8, 6))
sns.scatterplot(x='price', y='rating', data=new_data)
plt.title('Relationship between Price and Rating')
plt.xlabel('Price')
plt.ylabel('Rating')
plt.show()

# 4. Distribution of Price
plt.figure(figsize=(8, 6))
sns.histplot(df['price'], kde=True)
plt.title('Distribution of Phone Prices')
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.show()

# 5. Top Brands
plt.figure(figsize=(8, 6))
sns.countplot(x='brand_name', data=new_data, order=new_data['brand_name'].value_counts().index)
plt.title('Top Phone Brands')
plt.xlabel('Brand Name')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

# 6. Percentage of Phones with 5G
plt.figure(figsize=(8, 6))
sns.countplot(x='has_5g', data=new_data)
plt.title('Percentage of Phones with 5G')
plt.xlabel('Has 5G')
plt.ylabel('Count')
plt.show()

# 7. Percentage of Phones with NFC
plt.figure(figsize=(8, 6))
sns.countplot(x='has_nfc', data=new_data)
plt.title('Percentage of Phones with NFC')
plt.xlabel('Has NFC')
plt.ylabel('Count')
plt.show()

# 8. Percentage of Phones with IR Blaster
plt.figure(figsize=(8, 6))
sns.countplot(x='has_ir_blaster', data=new_data)
plt.title('Percentage of Phones with IR Blaster')
plt.xlabel('Has IR Blaster')
plt.ylabel('Count')
plt.show()

# 9. Distribution of RAM Capacity
plt.figure(figsize=(8, 6))
sns.histplot(new_data['ram_capacity'], kde=True)
plt.title('Distribution of RAM Capacity')
plt.xlabel('RAM Capacity (GB)')
plt.ylabel('Frequency')
plt.show()

# 10. Distribution of Internal Memory
plt.figure(figsize=(8, 6))
sns.histplot(new_data['internal_memory'], kde=True)
plt.title('Distribution of Internal Memory')
plt.xlabel('Internal Memory (GB)')
plt.ylabel('Frequency')
plt.show()

# 11. Distribution of Screen Size
plt.figure(figsize=(8, 6))
sns.histplot(new_data['screen_size'], kde=True)
plt.title('Distribution of Screen Size')
plt.xlabel('Screen Size (inches)')
plt.ylabel('Frequency')
plt.show()

# 12. Distribution of Refresh Rate
plt.figure(figsize=(8, 6))
sns.histplot(new_data['refresh_rate'], kde=True)
plt.title('Distribution of Refresh Rate')
plt.xlabel('Refresh Rate (Hz)')
plt.ylabel('Frequency')
plt.show()

# 13. Distribution of Number of Rear Cameras
plt.figure(figsize=(8, 6))
sns.countplot(x='num_rear_cameras', data=new_data)
plt.title('Distribution of Number of Rear Cameras')
plt.xlabel('Number of Rear Cameras')
plt.ylabel('Count')
plt.show()

# 14. Distribution of Number of Front Cameras
plt.figure(figsize=(8, 6))
sns.countplot(x='num_front_cameras', data=new_data)
plt.title('Distribution of Number of Front Cameras')
plt.xlabel('Number of Front Cameras')
plt.ylabel('Count')
plt.show()

# 15. Distribution of Battery Capacity
plt.figure(figsize=(8, 6))
sns.histplot(new_data['battery_capacity'], kde=True)
plt.title('Distribution of Battery Capacity')
plt.xlabel('Battery Capacity (mAh)')
plt.ylabel('Frequency')
plt.show()

# 16. Distribution of Fast Charging
plt.figure(figsize=(8, 6))
sns.countplot(x='fast_charging', data=new_data)
plt.title('Distribution of Fast Charging')
plt.xlabel('Fast Charging')
plt.ylabel('Count')
plt.show()

# 17. Distribution of Operating System
plt.figure(figsize=(8, 6))
sns.countplot(x='OS', data=new_data)
plt.title('Distribution of Operating System')
plt.xlabel('Operating System')
plt.ylabel('Count')
plt.show()

# 18. Distribution of Extended Memory
plt.figure(figsize=(8, 6))
sns.countplot(x='extended_memory', data=new_data)
plt.title('Distribution of Extended Memory')
plt.xlabel('Extended Memory')
plt.ylabel('Count')
plt.show()

sns.boxplot(x="model", y="price", data=new_data)
plt.show()

sns.histplot(data=new_data, x="price", kde=True, bins=30)
plt.show()

sns.scatterplot(data=new_data, x="price", y="rating", hue="model")
plt.show()

average_ratings = df.groupby("model")["rating"].mean()
average_ratings.plot(kind="bar")
plt.show()

